<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title> Python Logging: The Missing Guide &middot; Codey Oxley </title>


<link rel="stylesheet" href="css/slim.css">
<link rel="stylesheet" href="css/highlight.min.css">
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="Codey Oxley" />

</head>

<body>
  <div class="container">
    <div class="header">
  <h1 class="site-title"><a href="">Codey Oxley</a></h1>
  <p class="site-tagline"></p>
  <div class="nav">
    <a class="nav-btn" href="#">
      <span class="ci ci-burger"></span>
    </a>
    <ul class="nav-list">
       
	  <li class="spacer">&ac;</li>

      <li><a href="https://github.com/coxley">Github</a></li>  
    </ul>
  </div>
</div>
    <div class="content">
      <div class="posts">
        <div class="post">
          <h2 class="post-title"><a href="/logging/">Python Logging: The Missing Guide</a></h2>
          <span class="post-date">Apr 25, 2020 </span>
          <div class="post-content">
            

<p>Python loggers can be configured a million ways. That’s too much.</p>

<p>We can ease the pain by sticking to consistent practices. These patterns come from the most common issues that I see projects run into.</p>

<h1 id="naming">Naming</h1>

<p>Like modules, loggers are hierarchical. Their names should follow the import path of where they’re running. Loggers that stray from this are hard to work with. Use <code>__name__</code> everywhere to get this for free.</p>

<p>Follow this guideline for both libraries and CLI entry-points. Technically the name of <code>__main__</code>&rsquo;s logger doesn’t matter, but inconsistencies tend to spread.</p>

<pre><code class="language-python"># Module: foo/bar/baz.py

# GOOD: These are equivalent. Use the first one.
LOG = logging.getLogger(__name__)
LOG = logging.getLogger('foo.bar.baz')

# BAD: Cannot predict based on import path.
LOG = logging.getLogger('my_foo_baz')

# BAD: This is the root logger of the hierarchy.
#    : Libraries that use this cannot have their
#    : logs filtered by level without affecting
#    : everything else.
LOG = logging.getLogger()
LOG = logging.getLogger('')
LOG = logging.getLogger(None)
</code></pre>

<p>As a rule of thumb, just don’t use the root logger. Attach handlers, sure. But don’t use.</p>

<h1 id="hierarchy-handlers-filters">Hierarchy: Handlers &amp; Filters</h1>

<p>As a refresher, these settings are available to loggers:</p>

<ul>
<li>Min Level</li>
<li>Handlers</li>
<li>Filters</li>
</ul>

<p>Log names, split by period, make up the hierarchy. When logs are issued, they bubble up, visiting each handler, unless stopped by a filter. Or the minimum level.</p>

<p>This makes it handy to do things like:</p>

<ul>
<li>Exclude noisy logs from an import</li>
<li>Include helpful logs from an import</li>
<li>Format and print all program logs to <code>stderr</code></li>
</ul>

<p>Let’s demonstrate how this works:</p>

<pre><code class="language-python">import logging

# Set up silly handler that prints a name it's given when a log arrives
class DumbHandler(logging.Handler):
    def __init__(self, title: str, *args, **kwargs):
        self.title = title
        super().__init__(*args, **kwargs)

    def emit(self, record: logging.LogRecord):
        print(f&quot;{self.title}: {record.getMessage()}&quot;)


logging.root == logging.getLogger('')  # True
logging.root.setLevel(logging.DEBUG)   # Default level is WARNING

logging.root.addHandler(DumbHandler('root'))
logging.getLogger('project.foo').addHandler(DumbHandler('project.foo'))

logging.root.info('test')
# root: test

logging.getLogger('project.foo').info('test')
# project.foo: test
# root: test

logging.getLogger('project.foo.bar').setLevel(logging.WARNING)
logging.getLogger('project.foo.bar').info('test')
# &lt;nothing&gt;
</code></pre>

<h1 id="avoid-the-self-logger-pattern">Avoid the <code>self.logger</code> Pattern</h1>

<p>All calls to <code>logging.getLogger(name)</code> will return the same logger instance. Storing in an instance variable pollutes the logging call-site — which should be frequent!</p>

<pre><code class="language-python"># GOOD: At module level after imports
LOG = logging.getLogger(__name__)
def foo():
  LOG.info('...')

# BAD: Adds 8 more chars before message
class Foo:
  def __init__(self):
    self.logger = logging.getLogger(__name__)

  def bar(self):
    self.logger.info('...')

# BAD
def foo(logger: logging.Logger):
  logger.info('...')
</code></pre>

<p>If you need this to add unique handlers for contextual info, keep reading.</p>

<h1 id="adding-context">Adding Context</h1>

<p>This can be done in too many ways. For simplicity, I’ll show one method: my favorite.</p>

<p>It optimizes for:</p>

<ul>
<li>Zero special logger instances</li>
<li>Fewest number of Handlers (1)</li>

<li><p>No changes at logging call-site</p>

<pre><code class="language-python">&quot;&quot;&quot;
Use `contextvars` to share metadata with your log handler.

This works between imports, threads, and is `asyncio`-friendly.

The main gotcha is putting `copy_context().run` at the
right entry-point(s). And setting the variables soon
enough.
&quot;&quot;&quot;

import logging
import time

from contextvars import ContextVar, copy_context
from random import randint

LOG = logging.getLogger(__name__)

ReqID = ContextVar('req_id')

class ContextHandler(logging.Handler):
def emit(self, record: logging.LogRecord):
    msg = record.getMessage()
    if ReqID.get(None) is not None:
        msg = f&quot;[{ReqID.get()}] {msg}&quot;

    # Don't print.
    # Combine with logging over the network or use
    # a custom formatter attached to StreamHandler
    print(msg)


def do_work():
LOG.info(&quot;starting request...&quot;)
ReqID.set(randint(100, 500))
LOG.info(&quot;request finished&quot;)


# If you want to capture more logs from the program, attach handler
# at a higher level in the hierarchy.
#
# Perhaps even logging.root.
LOG.addHandler(ContextHandler())
LOG.setLevel(logging.INFO)
LOG.info(&quot;starting program&quot;)

copy_context().run(do_work)
copy_context().run(do_work)
copy_context().run(do_work)

# starting program
#
# starting request...
# [484] request finished
#
# starting request...
# [105] request finished
#
# starting request...
# [381] request finished
</code></pre></li>
</ul>

<p>For more information on <code>contextvars</code>, see: <a href="https://docs.python.org/3/library/contextvars.html">https://docs.python.org/3/library/contextvars.html</a></p>

<h1 id="logging-over-the-network">Logging Over the Network</h1>

<p>Use a queue with a flusher thread.</p>

<p>For every log issued, all handlers are run serially in the same thread as the call-site. Uploading messages to a database in-line turns microseconds into 20ms, 100ms, 500ms, and so on.</p>

<p>A project I worked on did this once. Jobs that landed in Europe took significantly longer to run. We figured out it was due to 500-1000ms round-trips for each log message.</p>

<pre><code class="language-python">import logging
import threading
from queue import Queue

LOG = logging.getLogger(__name__)

class DBHandler(logging.Handler):
    def __init__(self, q: Queue, *args, **kwargs):
        self.q = q
        super().__init__(*args, **kwargs)

    def emit(self, record: logging.LogRecord):
        # Format, convert log record to row, and send to queue
        # for insertion
        self.format(record)
        row = make_row(record)
        self.q.put(row)


def make_row(record: logging.LogRecord) -&gt; &quot;Row&quot;:
    # Use more columns than this
    return {&quot;msg&quot;: record.message}


def flusher(q: Queue):
    # Upload row instead of print. Perhaps flush every n-seconds
    # w/ buffer to have an upper-bound on inserts.
    while True:
        row = q.get()
        print(&quot;woohoo, recived:&quot;, row[&quot;msg&quot;])

q = Queue()
threading.Thread(target=flusher, daemon=True, args=(q,)).start()
LOG.setLevel(logging.INFO)
LOG.addHandler(DBHandler(q))

LOG.info(&quot;starting program&quot;)
LOG.info(&quot;doing some stuff&quot;)
LOG.info(&quot;mighty cool&quot;)
# woohoo, recived: starting program
# woohoo, recived: doing some stuff
# woohoo, recived: mighty cool
</code></pre>

<p>For <code>asyncio</code> in the flusher thread, <a href="https://github.com/aio-libs/janus/">use <code>janus.Queue</code></a>. It’s both <code>asyncio</code>-compatible and thread-safe: <a href="https://gist.github.com/coxley/14a1e3d98898132fa89c4e025cfa840f">https://gist.github.com/coxley/14a1e3d98898132fa89c4e025cfa840f</a></p>

<h1 id="duplicate-logs-in-terminal">Duplicate Logs in Terminal</h1>

<p>When logs print more than once, there are too many <code>StreamHandlers</code> attached. Use <code>logging.removeHandler</code> for a deterministic starting point.</p>

<pre><code class="language-python">for h in logging.root.handlers:
  if (
    isinstance(h, logging.StreamHandler) and
    getattr(h, &quot;stream&quot;, None) in (sys.stderr, sys.stdout)
  ):
    logging.root.removeHandler(h)

# Add the handler (and formatter) you want
</code></pre>

<p>Don’t attach <code>StreamHandler</code> within libraries. Configure the root logger from the program entry-point.</p>

          </div>
        </div>
        <div class="pagination"> 
        </div>
      </div>
    </div>
    
    <div class="footer">
  
  <p>Powered by <a href="https://gohugo.io">Hugo</a>. This theme—Slim—is open sourced on <a href="https://github.com/zhe/hugo-theme-slim">Github</a>.</p>
  
</div>

  </div>
  <script src="js/slim.js"></script>
  <script src="js/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-164601472-1', 'auto');
ga('send', 'pageview');

</script>

</body>

</html>
